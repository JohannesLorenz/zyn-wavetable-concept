# Wavetables

The term "wave table" or just "table" shall reference an array of a per-note-array of sample buffers, each generated with different parameters (like random seed, basewave function, maybe even basewave filter parameters in the future...).

For non-random-seed modulation through the tables, I now use the term "basewave modulation" to not confuse it with the "wavetable" term too much - It's modulation of parameters of the "basic wave" (the wave you see in the OscilGen editor), like the "basewave parameter" (sine->square, triangle->power...) or maybe a lowpass on the "base wave".

## Basic structure

Point 0 is explained in point 2 and 3, better read until there first.

**"Point 0"**: Table struct pseudo code

```
struct Shape2  { int dim[2]; };
struct Shape3  { int dim[3]; };
struct Tensor3<T> {
    Tensor3(Shape3, Allocator);
    T      *data;
    Shape3  shape;
};
struct Tensor2<T> {
    Tensor2(Shape2, Allocator);
    T      *data;
    Shape2  shape;
};

//Used to either obtain a tensor1 of NUM_OSCILGEN_SAMPLES+any mirrored ones
// or a tensor2 for extra antialiasing or wavetable efforts
//Each add note parameter oscillator has one of these structs
struct Wavetable {
    Tensor3<float32> data;  // time=col,freq=row,semantics(oscil param or random
    seed)=depth
    Tensor1<float32> freqs; // The frequency of each 'row'
    Tensor1<float32> semantics;

    mode //(freq)->samples, (freq, seed)->samples, (freq, wave param)->samples
    Tensor1<float32> get(freq); //works for both seed and seedless setups
    Tensor2<float32> get_antialiased(void);//works for seed and seedless setups
    Tensor2<float32> get_wavetablemod(freq);

    //if this is only adding new random seeds, then the rest of the data does
    //not need to be purged
    //                               (freq, seed|param?)
    void insert(Tensor3<float> data, Tensor2<float32> semantics, bool invalidate=true)

    //Used to determine if new random seeds are needed
    int number_of_remaining_seeds(void);
};

```

Similar to Pad synth, the individual waveforms are indexed by frequency and not
note as it is nontrivial to predict the basefreq/note correspondence.
The reason why the wavetable_t struct first indexes by parameter
and not frequency is because the played keys can't be easily predicted,
but the random seed or basewave parameter can be "predicted" or "chosen".
So the first element of `wavetable_t::buffer_of_note` can already be computed
and put into a ringbuffer as it is (discussed later in 3.1).

## Basic algorithm for random seeds

This is just replacing the current code, i.e. no new feature like "basewave modulation".

1. When an oscillator is changed within add synth Middleware will observe and detect the change
    1. The closest to this would be observing a message getting passed to the oscillator and then the prepare flag being set (I have not found such a callback. I think it's currently still done in OscilGen::prepare, which is currently called via ADnote::setupVoice -> OscilGen::get -> OscilGen::prepare in the worst case.)
2. In this callback, we call OscilGen::get (like in ADnote::setupVoice) N times (e.g. N = 128 or N = 512, we'll find out), each with different frequency and each of those with different random seed, and store all results in a new table in ADnoteVoiceParam (see 0).
    1. This callback must be in `MiddleWare`, not in the RT thread. Reason: Less overhead in audio thread. Even if we would just generate one wave per ADnote CTOR, consider the new basewave algorithm: It will call prepare() every ADnote CTOR, which would make the RT thread much busier than today. So for a clean design and for a common design between random-seed-table and basewave-table, I think it should really be in `MiddleWare`.
    2. The whole table can be generated "online" in `MiddleWare`, e.g. this can go into another thread while ADnote already picks the first available (optimization for later, let's keep it simple).
    3. The whole table can be generated by multiple threads, i.e. in parallel (optimization for later, let's keep it simple).
    4. If currently no random is used in the ADnoteParameters, the table is just one element (optimization for later, let's keep it simple).
    5. Note, this process will be something that can be optimized considerably
       in that it should be possible to avoid redundant calculations in get()
       due to different antialiasing cutoffs (for most settings)
3. ADnote::setupVoice now does not call OscilGen::get anymore outside of unit tests (The previous behavior should be maintained for unit tests to ease identifying regressions over a large range of versions). Instead, it gets the samples by using the wavetable to obtain the next random seed from the wave table from ADnoteVoiceParam.
    1. "Fetching" that table must be realtime safe. This means at the time of ADnote::setupVoice, `MiddleWare` has already sent some waves to the RT thread. This should be done by sending either full or partial wavetables (as full wavetable calculation may be sufficiently cheap) via the bToU buffer (that way, `MiddleWare` can generate waves "online" while ADnote already takes the first waves).
    2. While the table index for `wavetable_t::buffers_for_all_notes` is already calculated, the wave from the table is not yet referenced yet (in order to be conforming to 7.1) - minor detail.
    3. Additionally Middleware may generate new waves to a table using random
       seeds if it appears the majority of random seeds have already been played
       at least once
4. No further changes in `MiddleWare`, like moving objects to the non-RT store, should be required.

# Wavetable modulation

When this is all implemented, later, in a second step, basewave modulation (new feature) can be added:

5. Like in (1), there's a callback for when OscilGen parameters are changed
6. Like in (2), this callback generates the whole table, e.g. N waves with different parameters. No random is used here: If we have a table size of 128, they represent the 128 "basewave" parameters (e.g. triangle->power or sine->square).
    1. This can be extended to other parameters, e.g. the OscilGen filter parameters (filter modulation). Future extension.
    2. One difference to (2) is that OscilGen::prepare() must be called for each wave generation -> more overhead in MW thread.
    3. If it can already be guessed which basewave parameter is needed first, we start the generation with this parameter (optimization for later, let's keep it simple).
    4. Like in 6.3, if the basewave modulation is known to not span over all basewave parameters (e.g. only modulation in parameters 0->64), those should be generated first (optimization for later, let's keep it simple).
7. Like in (3), ADnote::setupVoice picks the right wave from the table. Every time a new buffer is calculated (ADnote::noteout), the index of the `wavetable_t::buffers_for_all_notes` is calculated (e.g. by using a basewave modulator or just a control element like a basewave knob). This parameter references the wave(s) from the table, which is then token and processed as usual.
    1. Actually, two elements of `wavetable_t::buffers_for_all_notes` may be token and then be interpolated.

# More considerations

8. The GUIs will probably not be changed for now. We try to develop an online algorithm that generates waves for the wave table bit by bit, while the first notes can already be played.
9. Like friedolino noted, currently, frequency modulation of ADnote can result in aliasing, as the used waves only use the nyquist frequency for their "normal" frequency. After the discussed algorithms are implemented, we can add a 4th dimension (optimization for later, let's keep it simple).
    1. This 4th dimension should be a struct containing multiple `wavetable_t`, see point 0, as this is the latest thing to compute - you can generate it for the "normal" frequency first, if you hit aliasing that's still better than wrong wavetable modulation (though maybe worse than hitting the wrong random seed?).
    2. I'm not sure about 9.0/9.1, the antialiasing mode can be handled with 2D
       interpolation for (seed)-><freq,time>, or 3D interpolation for
       <freq,parm,time>, so I don't know what 4th dimention is needed.

