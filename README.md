# Wavetables

The term "wave table" or just "table" shall reference an array of a per-note-array of sample buffers, each generated with different parameters (like random seed, basewave function, maybe even basewave filter parameters in the future...).

For non-random-seed modulation through the tables, I now use the term "basewave modulation" to not confuse it with the "wavetable" term too much - It's modulation of parameters of the "basic wave" (the wave you see in the OscilGen editor), like the "basewave parameter" (sine->square, triangle->power...) or maybe a lowpass on the "base wave".

## Basic structure

Point 0 is explained in point 2 and 3, better read until there first.

**"Point 0"**: Table struct pseudo code

```
struct buffer_t {
    float samples[NUM_OSCILGEN_SAMPLES (+ additional samples)]; // index is time
};

struct buffers_for_all_notes {
    buffer_t buffers[NUM_KEYS]; // index is note (e.g. "C4"), aka. "frequency"
};

struct wavetable_t { // ADnoteVoiceParam has one of this struct
    buffers_for_all_notes buffer_of_note[TABLE_SIZE]; // index is random seed/basewave param/...
};
```

The reason why the wavetable_t struct first indexes by parameter and not frequency is because the played keys can't be easily predicted, but the random seed or basewave parameter can be "predicted" or "chosen". So the first element of `wavetable_t::buffer_of_note` can already be computed and put into a ringbuffer as it is (discussed later in 3.1).

## Basic algorithm for random seeds

This is just replacing the current code, i.e. no new feature like "basewave modulation".

1. There must be a member function for ADnoteVoiceParam which is called whenever an OscilGen parameter is changed, e.g. by the GUI
    1. I have not found such a callback. I think it's currently still done in OscilGen::prepare, which is currently called via ADnote::setupVoice -> OscilGen::get -> OscilGen::prepare in the worst case.
    2. If no such callback exists in ADnoteVoiceParam, we may create one (maybe it should be called in the "OscilSmp/" port of "voicePorts"?).
2. In this callback, we call OscilGen::get (like in ADnote::setupVoice) N times (e.g. N = 128 or N = 512, we'll find out), each with different frequency and each of those with different random seed, and store all results in a new table in ADnoteVoiceParam (see 0).
    1. This callback must be in `MiddleWare`, not in the RT thread. Reason: Less overhead in audio thread. Even if we would just generate one wave per ADnote CTOR, consider the new basewave algorithm: It will call prepare() every ADnote CTOR, which would make the RT thread much busier than today. So for a clean design and for a common design between random-seed-table and basewave-table, I think it should really be in `MiddleWare`.
    2. The whole table can be generated "online" in `MiddleWare`, e.g. this can go into another thread while ADnote already picks the first available (optimization for later, let's keep it simple).
    3. The whole table can be generated by multiple threads, i.e. in parallel (optimization for later, let's keep it simple).
    4. If currently no random is used in the ADnoteParameters, the table is just one element (optimization for later, let's keep it simple).
3. ADnote::setupVoice now does not call OscilGen::get anymore. Instead, it gets the samples by picking a random index (no new seed, just one random number), so it can "fetch" the pre-calculated wave table from ADnoteVoiceParam.
    1. "Fetching" that table must be realtime safe. This means at the time of ADnote::setupVoice, `MiddleWare` has already sent some waves to the RT thread. This should be done by sending wave per wave via the bToU buffer (that way, `MiddleWare` can generate waves "online" while ADnote already takes the first waves).
    2. While the table index for `wavetable_t::buffers_for_all_notes` is already calculated, the wave from the table is not yet referenced yet (in order to be conforming to 7.1) - minor detail.
4. No further changes in `MiddleWare`, like moving objects to the non-RT store, should be required.

# Wavetable modulation

When this is all implemented, later, in a second step, basewave modulation (new feature) can be added:

5. Like in (1), there's a callback for when OscilGen parameters are changed
6. Like in (2), this callback generates the whole table, e.g. N waves with different parameters. No random is used here: If we have a table size of 128, they represent the 128 "basewave" parameters (e.g. triangle->power or sine->square).
    1. This can be extended to other parameters, e.g. the OscilGen filter parameters (filter modulation). Future extension.
    2. One difference to (2) is that OscilGen::prepare() must be called for each wave generation -> more overhead in MW thread.
    3. If it can already be guessed which basewave parameter is needed first, we start the generation with this parameter (optimization for later, let's keep it simple).
    4. Like in 6.3, if the basewave modulation is known to not span over all basewave parameters (e.g. only modulation in parameters 0->64), those should be generated first (optimization for later, let's keep it simple).
7. Like in (3), ADnote::setupVoice picks the right wave from the table. Every time a new buffer is calculated (ADnote::noteout), the index of the `wavetable_t::buffers_for_all_notes` is calculated (e.g. by using a basewave modulator or just a control element like a basewave knob). This parameter references the wave(s) from the table, which is then token and processed as usual.
    1. Actually, two elements of `wavetable_t::buffers_for_all_notes` may be token and then be interpolated.

# More considerations

8. The GUIs will probably not be changed for now. We try to develop an online algorithm that generates waves for the wave table bit by bit, while the first notes can already be played.
9. Like friedolino noted, currently, frequency modulation of ADnote can result in aliasing, as the used waves only use the nyquist frequency for their "normal" frequency. After the discussed algorithms are implemented, we can add a 4th dimension (optimization for later, let's keep it simple).
    1. This 4th dimension shoud be a struct containing multiple `wavetable_t`, see point 0, as this is the latest thing to compute - you can generate it for the "normal" frequency first, if you hit aliasing that's still better than wrong wavetable modulation (though maybe worse than hitting the wrong random seed?).

